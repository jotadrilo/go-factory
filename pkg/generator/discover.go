package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/jotadrilo/go-factory/pkg/config"
	"github.com/jotadrilo/go-factory/pkg/log"
)

type Discoverer interface {
	LoadPackage(pkg config.Package) (*PackageTree, error)
	LoadDir(pkg config.Package, pkgDir string) (*PackageTree, error)
	LoadFile(pkg config.Package, pkgDir string, pkgFile string) (*FileTree, error)
}

type FileTreeDiscoverer struct {
	Config *config.Config
}

func NewFileTreeDiscoverer(config *config.Config) *FileTreeDiscoverer {
	return &FileTreeDiscoverer{
		Config: config,
	}
}

func (x *FileTreeDiscoverer) LoadPackage(pkg config.Package) (*PackageTree, error) {
	if pkg.FactoryFileTpl == "" {
		pkg.FactoryFileTpl = config.DefaultFactoryFileTpl
	}

	// We have to discover the folder of the given package and parse all Go files inside
	pkgDir, err := discoverPackageDir(pkg.Name)
	if err != nil {
		return nil, err
	}

	return x.LoadDir(pkg, pkgDir)
}

func (x *FileTreeDiscoverer) LoadDir(pkg config.Package, pkgDir string) (*PackageTree, error) {
	var pt = PackageTree{
		Config: pkg,
		Dir:    pkgDir,
	}

	if err := filepath.WalkDir(pkgDir, func(pkgFile string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Ignore directories
		// We only want to process Go files present in the package directory
		if d.IsDir() {
			// Don't skip the root directory
			if pkgFile != pkgDir {
				return filepath.SkipDir
			}

			return nil
		}

		// Skip non-Go files
		if filepath.Ext(pkgFile) != ".go" {
			return nil
		}

		log.Logger.Infof("Discovering structs in %s file", pkgFile)
		ft, err := x.LoadFile(pkg, pkgDir, pkgFile)
		if err != nil {
			return err
		}

		pt.FileTrees = append(pt.FileTrees, ft)

		return nil
	}); err != nil {
		return nil, err
	}

	return &pt, nil
}

func (x *FileTreeDiscoverer) LoadFile(pkg config.Package, pkgDir string, pkgFile string) (*FileTree, error) {
	var ft FileTree

	node, err := parser.ParseFile(token.NewFileSet(), pkgFile, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	t, err := template.New("FactoryFileTpl").Parse(pkg.FactoryFileTpl)
	if err != nil {
		return nil, err
	}

	var (
		includeStructsIndex = make(map[string]any, len(pkg.Include))
		excludeStructsIndex = make(map[string]any, len(pkg.Exclude))
	)

	for _, name := range pkg.Include {
		includeStructsIndex[name] = struct{}{}
	}
	for _, name := range pkg.Exclude {
		excludeStructsIndex[name] = struct{}{}
	}

	var discoverable = func(name string) bool {
		// Ignore private structs
		if !unicode.IsUpper([]rune(name)[0]) {
			return false
		}

		// We can discover all structs if these fields are both empty
		if len(pkg.Include) == 0 && len(pkg.Exclude) == 0 {
			return true
		}

		_, excluded := excludeStructsIndex[name]
		_, included := includeStructsIndex[name]

		if len(pkg.Include) == 0 {
			return !excluded
		}

		if len(pkg.Exclude) == 0 {
			return included
		}

		return included && !excluded
	}

	var (
		pkgName string
	)

	for _, imp := range node.Imports {
		// The import path value is a quoted string
		importPath := strings.Trim(imp.Path.Value, `"`)
		if imp.Name != nil {
			// Aliased import
			ft.Imports = append(ft.Imports, &Import{
				Alias: imp.Name.Name,
				Path:  importPath,
			})
		} else {
			// Regular import
			ft.Imports = append(ft.Imports, &Import{
				Name: importPath[strings.LastIndex(importPath, "/")+1:],
				Path: importPath,
			})
		}
	}

	ast.Inspect(node, func(n ast.Node) bool {
		// Skip file if it has been generated by this tool
		for _, comment := range node.Comments {
			for _, header := range validHeaders {
				if strings.Contains(comment.Text(), header) {
					log.Logger.Infof("Excluding %s file (generated)", pkgFile)
					return false
				}
			}
		}

		if pn, ok := n.(*ast.File); ok && pkgName == "" {
			pkgName = pn.Name.Name
		}

		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}

		var typeName = ts.Name.Name
		if !discoverable(typeName) {
			log.Logger.Infof("Discovered %s struct, but it is not required", typeName)
			return true
		}

		log.Logger.Infof("Discovered %s struct", typeName)

		var (
			pkgFileBase = filepath.Base(pkgFile)
			pkgFileExt  = filepath.Ext(pkgFile)
			// We know that the extension is .go
			// However, let's be safe here just in case Go decides to introduce a different extension
			// for some reason
			pkgFilename = pkgFileBase[:len(pkgFileBase)-len(pkgFileExt)]
		)

		pkgDirRel, _ := filepath.Rel(x.Config.ProjectDir, pkgDir)

		var strct = &Struct{
			ProjectDir:    x.Config.ProjectDir,
			PackageRoot:   pkg.Name,
			PackageName:   pkgName,
			PackageDir:    pkgDir,
			PackageDirRel: pkgDirRel,
			FilePath:      pkgFile,
			Filename:      pkgFilename,
			TypeName:      typeName,
		}

		for _, field := range st.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			strct.Fields = append(strct.Fields, NewField(field.Names[0].Name, field.Type))
		}

		var data bytes.Buffer
		if err := t.Execute(&data, strct); err != nil {
			log.Logger.Warnf("Cannot render %s template: %s", t.Name(), err)
			return false
		}

		strct.FactoryFileTpl = data.String()

		ft.Structs = append(ft.Structs, strct)

		return true
	})

	return &ft, nil
}

func discoverPackageDir(pkg string) (string, error) {
	var (
		cmd    = exec.Command("go", "list", "-f", "{{.Dir}}", pkg)
		stdout bytes.Buffer
		stderr bytes.Buffer
	)

	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to locate package: %s (%s)", strings.TrimSpace(stderr.String()), strings.TrimSpace(err.Error()))
	}

	return strings.TrimSpace(stdout.String()), nil
}
